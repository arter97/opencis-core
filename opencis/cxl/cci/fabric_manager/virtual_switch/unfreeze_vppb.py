"""
Copyright (c) 2025, Eeum, Inc.

This software is licensed under the terms of the Revised BSD License.
See LICENSE for details.
"""

from dataclasses import dataclass
import struct

from opencis.cxl.component.cci_executor import (
    CciBackgroundCommand,
    CciRequest,
    CciResponse,
    ProgressCallback,
)
from opencis.cxl.component.virtual_switch_manager import VirtualSwitchManager
from opencis.cxl.cci.common import CCI_FM_API_COMMAND_OPCODE, CCI_RETURN_CODE
from opencis.util.logger import logger

"""

The following dataclass is generated by ChatGPT (GPT-4)

"""


# pylint: disable=duplicate-code


@dataclass
class UnfreezeVppbRequestPayload:
    vcs_id: int = 0
    vppb_id: int = 0
    pack_mask: str = "<BB"

    @classmethod
    def parse(cls, data: bytes) -> "UnfreezeVppbRequestPayload":
        if len(data) != struct.calcsize(cls.pack_mask):
            raise ValueError("Data is too short to parse.")
        (
            vcs_id,
            vppb_id,
        ) = struct.unpack(cls.pack_mask, data)

        return cls(
            vcs_id=vcs_id,
            vppb_id=vppb_id,
        )

    def dump(self) -> bytes:
        databytes = struct.pack(
            self.pack_mask,
            self.vcs_id,
            self.vppb_id,
        )
        return databytes

    def get_pretty_print(self) -> str:
        return f"- Virtual CXL Switch ID: {self.vcs_id}\n" f"- vPPB ID: {self.vppb_id}\n"


class UnfreezeVppbCommand(CciBackgroundCommand):
    OPCODE = CCI_FM_API_COMMAND_OPCODE.UNFREEZE_VPPB

    def __init__(self, virtual_switch_manager: VirtualSwitchManager):
        super().__init__(self.OPCODE)
        self._virtual_switch_manager = virtual_switch_manager

    async def _execute(self, request: CciRequest, callback: ProgressCallback) -> CciResponse:
        request_payload = self.parse_request_payload(request.payload)
        vcs_id = request_payload.vcs_id
        vppb_id = request_payload.vppb_id
        vcs_count = self._virtual_switch_manager.get_virtual_switch_counts()
        if vcs_id >= vcs_count:
            logger.debug(self._create_message("VCS ID is out of bound"))
            return CciResponse(return_code=CCI_RETURN_CODE.INVALID_INPUT)

        vcs = self._virtual_switch_manager.get_virtual_switch(vcs_id)
        if vppb_id >= vcs.get_vppb_counts():
            logger.debug(self._create_message("vPPB ID is out of bound"))
            return CciResponse(return_code=CCI_RETURN_CODE.INVALID_INPUT)

        if not vcs.is_vppb_bound(vppb_id):
            logger.error(
                self._create_message(f"vPPB {vppb_id} is unbound, unable to send unfreeze command")
            )
            return CciResponse(return_code=CCI_RETURN_CODE.INVALID_INPUT)

        await callback(50)

        await vcs.unfreeze_vppb(vppb_id)
        response = CciResponse()
        return response

    @classmethod
    def create_cci_request(
        cls,
        request: UnfreezeVppbRequestPayload,
    ) -> CciRequest:
        cci_request = CciRequest()
        cci_request.opcode = cls.OPCODE
        cci_request.payload = request.dump()
        return cci_request

    @staticmethod
    def parse_request_payload(payload: bytes) -> UnfreezeVppbRequestPayload:
        return UnfreezeVppbRequestPayload.parse(payload)
